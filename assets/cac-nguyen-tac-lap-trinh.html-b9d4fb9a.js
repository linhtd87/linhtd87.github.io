const n=JSON.parse('{"key":"v-293a3a4a","path":"/pages/Coding/cac-nguyen-tac-lap-trinh.html","title":"Các nguyên tắc lập trình","lang":"vi-VN","frontmatter":{"title":"Các nguyên tắc lập trình","cover":"/assets/images/cover-coding.webp","icon":"file","order":1,"author":"Mr.Linh","date":"2020-01-01T00:00:00.000Z","category":["coding"],"tag":["Các nguyên tắc lập trình","principles in software design"],"sticky":false,"star":true,"copyright":"No Copyright","description":"Các nguyên tắc lập trình SOLID Trong thế giới năng động của phát triển phần mềm, việc viết mã có thể duy trì và mở rộng là rất quan trọng đối với sự thành công của bất kỳ dự án nào. Các nguyên tắc thiết kế SOLID cung cấp một bộ hướng dẫn có thể giúp các nhà phát triển đạt được chính xác điều đó. Được phát triển bởi Robert C. Martin (Uncle Bob), những nguyên tắc này đã trở thành nền tảng của kiến trúc phần mềm hiện đại. Trong bài đăng này, tôi sẽ khám phá sâu từng nguyên tắc SOLID, hiểu tầm quan trọng của nó và tìm hiểu cách áp dụng chúng một cách hiệu quả với các ví dụ mã hóa thực tế.","head":[["meta",{"property":"og:url","content":"https://linhtd.site/pages/Coding/cac-nguyen-tac-lap-trinh.html"}],["meta",{"property":"og:site_name","content":"LinhTD.site"}],["meta",{"property":"og:title","content":"Các nguyên tắc lập trình"}],["meta",{"property":"og:description","content":"Các nguyên tắc lập trình SOLID Trong thế giới năng động của phát triển phần mềm, việc viết mã có thể duy trì và mở rộng là rất quan trọng đối với sự thành công của bất kỳ dự án nào. Các nguyên tắc thiết kế SOLID cung cấp một bộ hướng dẫn có thể giúp các nhà phát triển đạt được chính xác điều đó. Được phát triển bởi Robert C. Martin (Uncle Bob), những nguyên tắc này đã trở thành nền tảng của kiến trúc phần mềm hiện đại. Trong bài đăng này, tôi sẽ khám phá sâu từng nguyên tắc SOLID, hiểu tầm quan trọng của nó và tìm hiểu cách áp dụng chúng một cách hiệu quả với các ví dụ mã hóa thực tế."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://linhtd.site/assets/images/cover-coding.webp"}],["meta",{"property":"og:locale","content":"vi-VN"}],["meta",{"property":"og:updated_time","content":"2023-11-06T10:58:54.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"Các nguyên tắc lập trình"}],["meta",{"property":"article:author","content":"Mr.Linh"}],["meta",{"property":"article:tag","content":"Các nguyên tắc lập trình"}],["meta",{"property":"article:tag","content":"principles in software design"}],["meta",{"property":"article:published_time","content":"2020-01-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-11-06T10:58:54.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Các nguyên tắc lập trình\\",\\"image\\":[\\"https://linhtd.site/assets/images/cover-coding.webp\\"],\\"datePublished\\":\\"2020-01-01T00:00:00.000Z\\",\\"dateModified\\":\\"2023-11-06T10:58:54.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Linh\\"}]}"]]},"headers":[{"level":2,"title":"SOLID","slug":"solid","link":"#solid","children":[{"level":3,"title":"1. Nguyên tắc trách nhiệm duy nhất (Single Responsibility Principle SRP):","slug":"_1-nguyen-tac-trach-nhiem-duy-nhat-single-responsibility-principle-srp","link":"#_1-nguyen-tac-trach-nhiem-duy-nhat-single-responsibility-principle-srp","children":[]},{"level":3,"title":"2. Nguyên tắc mở-đóng (Open-Closed Principle OCP):","slug":"_2-nguyen-tac-mo-đong-open-closed-principle-ocp","link":"#_2-nguyen-tac-mo-đong-open-closed-principle-ocp","children":[]},{"level":3,"title":"3. Nguyên tắc thay thế Liskov (Liskov Substitution Principle LSP):","slug":"_3-nguyen-tac-thay-the-liskov-liskov-substitution-principle-lsp","link":"#_3-nguyen-tac-thay-the-liskov-liskov-substitution-principle-lsp","children":[]},{"level":3,"title":"4. Nguyên tắc phân tách giao diện (Interface Segregation Principle ISP):","slug":"_4-nguyen-tac-phan-tach-giao-dien-interface-segregation-principle-isp","link":"#_4-nguyen-tac-phan-tach-giao-dien-interface-segregation-principle-isp","children":[]},{"level":3,"title":"5. Nguyên tắc đảo ngược phụ thuộc (Dependency Inversion Principle DIP):","slug":"_5-nguyen-tac-đao-nguoc-phu-thuoc-dependency-inversion-principle-dip","link":"#_5-nguyen-tac-đao-nguoc-phu-thuoc-dependency-inversion-principle-dip","children":[]}]}],"git":{"createdTime":1699268334000,"updatedTime":1699268334000,"contributors":[{"name":"Trinh Duy Linh","email":"linh.td@trans-tech.vn","commits":1}]},"readingTime":{"minutes":4.76,"words":1427},"filePathRelative":"pages/Coding/cac-nguyen-tac-lap-trinh.md","localizedDate":"1 tháng 1 năm 2020","excerpt":"<h1> Các nguyên tắc lập trình</h1>\\n<h2> SOLID</h2>\\n<p>Trong thế giới năng động của phát triển phần mềm, việc viết mã có thể duy trì và mở rộng là rất quan trọng đối với sự<br>\\nthành công của bất kỳ dự án nào. Các nguyên tắc thiết kế SOLID cung cấp một bộ hướng dẫn có thể giúp các nhà phát triển<br>\\nđạt được chính xác điều đó. Được phát triển bởi Robert C. Martin (Uncle Bob), những nguyên tắc này đã trở thành nền tảng<br>\\ncủa kiến trúc phần mềm hiện đại. Trong bài đăng này, tôi sẽ khám phá sâu từng nguyên tắc SOLID, hiểu tầm quan trọng của<br>\\nnó và tìm hiểu cách áp dụng chúng một cách hiệu quả với các ví dụ mã hóa thực tế.</p>","autoDesc":true}');export{n as data};
